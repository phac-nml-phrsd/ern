#' A single realization of the Rt estimate
#'
#' @param cl.daily Dataframe of inferred daily incidence.
#' @inheritParams estimate_R_cl
#'
#'
#' @export
estimate_R_cl_single <- function(
    cl.daily,
    dist.repfrac,
    dist.repdelay,
    dist.incub,
    dist.gi,
    prm.R,
    silent = FALSE
){

  # sample one realization of reports.daily (smoothed)
  id.list <- unique(cl.daily$id)
  the_id  <- sample(id.list, size = 1)
  df.draw <- (cl.daily
     %>% dplyr::filter(id == the_id)
  )

  # sample reporting fraction
  reporting.fraction.draw <- sample_from_dist(
    n = 1,
    params = dist.repfrac
  )

  # sample reporting delay distribution
  reporting.delay <- sample_a_dist(dist.repdelay)

  # sample incubation period
  incubation.period <- sample_a_dist(dist.incub)

  # sample generation interval
  generation.interval <- sample_a_dist(dist.gi)

  # correct for underreporting
  reports.daily.scaled <- correct_underreporting(
    df.draw,
    reporting.fraction.draw
  )

  # reports deconvoluted with reporting delay distribution
  # and then with incubation period distribution
  incidence <- reports_to_incidence(
    reports.daily.scaled,
    reporting.delay,
    incubation.period,
    silent = silent  ) %>%
    # attach time index to incidence
    dplyr::mutate(t = 1:nrow(.))

  # estimate Rt
  res = incidence_to_R(
    incidence,
    generation.interval,
    prm.R)

  return(res)
}


# helpers -----------------------------------------------------------------

#' Correct underreporting by scaling up
#'
#' @param reports.daily dataframe of daily reported cases. must at least include `value` column with counts.
#' @param reporting.fraction numeric. proportion of incidence that is reported.
#'
correct_underreporting <- function(
    reports.daily,
    reporting.fraction
){
  (reports.daily
   %>% dplyr::mutate(value = value/reporting.fraction)
  )
}

#' Infer incidence from reports via a series of deconvolutions
#'
#' @param reports.daily Data frame. Daily report counts. Includes at least `date` and `value` columns.
#' @param reporting.delay List. Parameters for a single reporting delay distribution, as generated by [sample_a_dist()].
#' @param incubation.period List. Parameters for a single incubation period distribution, as generated by [sample_a_dist()].
#' @inheritParams deconv
#' @inheritParams estimate_R_cl
#'
#'
#' @seealso [`def_dist_incubation_period()`]
reports_to_incidence <- function(
    reports.daily,
    reporting.delay,
    incubation.period,
    max.iter = 50,
    silent = FALSE
){

  # reports -> onsets
  # - - - - - - - - - - - - - - - - -

  # deconv reports with reporting delay distribution
  if(!silent){
    message("-----
Deconvolving inferred daily reports with reporting delay
distribution to get daily onsets...")
  }
  onsets <- deconv(
    counts = reports.daily$value,
    dist = get_discrete_dist(reporting.delay),
    max.iter = max.iter,
    silent = silent
  )

  # onsets -> incidence
  # - - - - - - - - - - - - - - - - -

  # deconv onsets with incubation period distribution
  if(!silent){
    message("-----
Deconvolving daily onsets with incubation period
distribution to get daily incidence...")
  }
  incidence <- deconv(
    counts = onsets$y,
    dist = get_discrete_dist(incubation.period),
    max.iter = max.iter,
    silent = silent
  )

  # output
  # - - - - - - - - - - - - - - - - -

  date.lookup <- tibble::tibble(
    date = reports.daily$date,
    t = 1:nrow(reports.daily)
  )

  (incidence
    # filter out first x days, where x is the sum of
    # the max reporting delay and the max incubation period
    # (i.e. disregard reports before a full observation period is complete)
    # %>% dplyr::filter(t >= incubation.period$max + reporting.delay$max)
    %>% dplyr::left_join(date.lookup, by = "t")
    %>% dplyr::transmute(
      date,
      I = y
    )
    %>% tibble::as_tibble()
  )
}

#' Wrapper for deconvolution with a given distribution
#'
#' @param counts Numeric. Vector of daily counts.
#' @param dist Numeric. Vector of discrete distributions (daily, truncated) with which we're deconvoluting counts, _e.g._, produced by [`get_discrete_dist()`]
#' @param max.iter Numeric. Maximum number of Richardson-Lucy iterations.
#' @inheritParams estimate_R_cl
#'
#' @seealso [`get_discrete_dist()`]
deconv <- function(
    counts,
    dist,
    max.iter = 10,
    silent = FALSE
){
  # check args
  # - - - - - - - - - - - - - - - - -
  check_for_deconv(counts, dist)

  # perform Richardson-Lucy deconvolution
  (deconvolution_RL(
    observed = counts,
    times = 1:length(counts),
    p_delay = dist,
    max_iter = max.iter,
    verbose = !silent
  )
  %>% tidyr::drop_na()
  %>% dplyr::rename(
    t = time,
    y = RL_result)
  )
}
