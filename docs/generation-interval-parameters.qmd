---
title: "Estimating parameters for the generation interval distribution of SARS-CoV-2 Omicron"
author: "Irena Papst"
format:
  html:
      embed-resources: true
editor: visual
---

```{r setup}
library(glue)
library(tibble)
```

## Motivation

In order to calculate Rt, we need to assume a generation interval. For COVID-19 in Canada, the most relevant parameter estimates come from analyzing Omicron infection data as the majority of lineages circulating in the country since January 2021 have been descendants of Omicron.

Daniel Park suggested using [Manica *et al.* 2022](https://www.sciencedirect.com/science/article/pii/S2666776222001405) to get parameter estimates for a Gamma-distributed intrinsic generation interval for Omicron, along with a measure of uncertainty around each parameter estimate. They also have estimates for the incubation period, which we also need.

We want a measure of uncertainty around each distribution parameter because we want to propagate uncertainty in the specification of the generation interval through to the $R_t$ calculation. We want to start with distribution parameters along with uncertainty around each parameter and use these givens to parameterize a *family* of generation interval distributions. Then we calculate $R_t$ using an ensemble, where for each realization we draw from the family of distributions to specify one generation interval distribution to use for that calculation.

## The catch

In the `ern` package, we have infrastructure to calculate $R_t$ with a family of distributions as described above where the family is specified by:

-   a distribution type (*e.g.* Gamma, log-normal)

-   a distribution mean

-   a standard deviation about that mean

-   a distribution standard deviation

-   a standard deviation about that standard deviation

However, in the Manica *et al.* paper, they give their parameter estimates as follows:

![](figs/manica-table2.png){fig-align="center"}

Here we have estimates for the mean, shape, and scale parameters. Of course, knowing at least two of these, we can reparameterize a Gamma in terms of the mean and standard deviation---that's not the problem. The problem is that **the uncertainty in each estimated parameter is reported in terms of a credible interval**, *i.e.* in a non-parametric way. We need a parameteric approach to draw from the associated family of distributions for each realization of our $R_t$ calculation.

These credible intervals emerge as a summary of the Bayesian posterior distribution of each parameter. However, I didn't find any information in the paper (or its appendices) that would help parameterize these distributions...

## Ben & dC to the rescue

I talked to Ben Bolker about this problem and he pointed out:

> Bayesian posterior distributions do not generally have known/assumed functional forms; they emerge from the forms chosen for the likelihood and the priors (\*if\* one chooses a conjugate prior then the form of the posterior is analytically tractable \-- otherwise it's just whatever comes out of the sampler).

Ben suggested something that David Champredon had described to me earlier: assume each distribution parameter is itself Gamma distributed (or log-normal, or another continuous distribution with non-negative support since these parameters must be non-negative). Then, assume the credible interval bounds give quantiles of this distribution and use them, along with a mean (equal to the mean estimate of the focal parameter) to fit a Gamma distribution.

However, for the generation interval, we need to fit distributions over two parameters to specify it. Ben suggested doing two independent one-dimensional optimizations to fit distributions for mean and the shape of the generation interval distribution. According to Ben, for the Gamma, the shape and scale are likely more strongly correlated than the mean and shape, hence why we should choose the latter pair for two independent one-dimensional optimizations. Alternatively, one should instead perform a two-dimensional optimization over shape and scale simultaneously.

## The method

For each distribution parameter we're trying to fit (*i.e.*, generation interval mean and generation interval shape), we have the distribution mean and 95% credible interval bounds. Fix the mean as if it's the truth, and optimize over the unknown shape parameter. (Once we have that in hand we can derive a standard deviation to fit within our current framework for specifying distributions.)

## The doing

Some sample code to accomplish the optimization task as described above:

```{r optim_base}
score_fun <- function(s, m = 3.49, ci_target = c(3.17, 3.77)) {
  # define gamma parameters
  shape <- s
  scale <- m/s
  # get quantiles
  ci <- qgamma(c(0.025, 0.975), shape = shape, scale = scale)
  # calculate sum of square differences as a score
  return(sum((ci-ci_target)^2))
}

opt_out <- optim(
  # initial value for shape
  par = 1, 
  # scoring function
  fn = score_fun,
  # bounds on shape
  lower = 0.0001, upper = 1000,
  method = "Brent"
)

shape_best <- opt_out$par
sd_best <- 3.49/sqrt(shape_best)

print(glue("fitted sd: {round(sd_best, 4)}"))
print(glue("min sum of squared diffs: {round(opt_out$value, 6)}"))
```

In the code above, we use the following little calculation to derive the formula for the standard deviation, $\sigma$, of a Gamma distribution given the mean, $\mu$, and shape parameter, $\alpha$ (via the scale parameter, $\beta$):

$$
\begin{align}
\mu = \alpha\beta&, \quad \sigma^2 = \alpha\beta^2 \\ \\
\beta &= \mu/\alpha \\
\sigma^2 &= \alpha\beta^2 \\
&= \alpha(\mu/\alpha)^2 \\
&= \alpha\mu^2/\alpha^2 \\
&=\mu^2/\alpha \\ \\
\sigma &= \mu/\sqrt{\alpha}
\end{align}
$$

We'll encode this formula in a function for later use:

```{r shape_to_sd}
shape_to_sd <- function(shape, mean) mean/sqrt(shape)
```

Let's wrap this in another function where we specify the mean and credible interval bounds and get out the standard deviation:

```{r optim_wrapped}
make_score_fun <- function(){
  
  score_fun <- function(s, m, ci_target) {
    shape <- s
    scale <- m/s
    ci <- qgamma(c(0.025, 0.975), shape = shape, scale = scale)
    return(sum((ci-ci_target)^2))
  }
  
  return(score_fun)
}

fit_sd <- function(mean, ci){
  score_fun <- make_score_fun()

  opt_out <- optim(
    par = 1, 
    fn = score_fun,
    m = mean,
    ci_target = ci,
    lower = 0.0001, upper = 1000,
    method = "Brent"
  )
  
  # get best shape parameter found and return standard deviation
  shape_best <- opt_out$par
  sd_best <- shape_to_sd(shape_best, mean)
  
  return(list(
    sd = sd_best,
    score = opt_out$value
  ))
}
```

Let's make sure we get the same fitted parameter as in the base code above using our wrapped function:

```{r optim_wrapped_test}
print_fit_sd <- function(mean, ci){
  fit <- fit_sd(mean, ci)
  print(glue("fitted sd: {round(fit$sd, 4)}"))
  print(glue("min sum of squared diffs: {round(fit$score, 6)}"))
}

print_fit_sd(mean = 3.49, ci = c(3.17, 3.77))
```

Looks good!

## Fitted parameter values

Here is a summary of the fitted parameter values using the code above:

```{r fit_all_table, echo = FALSE}
fit.gi.mean <- fit_sd(mean = 6.84, ci = c(5.72, 8.60))
fit.gi.shape <- fit_sd(mean = 2.39, ci = c(2.01, 3.34))

tb <- tribble(
  ~distribution,         ~parameter,         ~`value type`,                  ~`value`,
  "generation interval", "mean",              "mean (assumed)",              6.84,
  "",                    "",                  "standard deviation (fitted)", fit.gi.mean$sd,
  "",                    "",                  "fit score",                   fit.gi.mean$score,
  "",                    "shape",             "mean (assumed)",              2.39,
  "",                    "",                  "standard deviation (fitted)", fit.gi.shape$sd,
  "",                    "",                  "fit score",                   fit.gi.shape$score,
  "",                    "standard deviation", "mean (from mean and shape)",  shape_to_sd(shape = 2.39, mean = 6.84),
  "",                    "",                  "standard deviation (from mean and shape)", as.numeric(NA)
)
knitr::kable(tb)
```

## Todo

-   figure out how to get `sd` and `sd_sd` from mean and shape fits

-   convert the table to a function that generates the table

-   make the table for the incubation period

-   send this doc to steve
